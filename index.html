<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Scoring System</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
:root {
--primary: #2563eb;
--primary-dark: #1d4ed8;
--secondary: #10b981;
--success: #22c55e;
--warning: #f59e0b;
--danger: #ef4444;
--light: #f8fafc;
--dark: #0f172a;
--gray: #64748b;
--light-gray: #e2e8f0;
--white: #ffffff;
--shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
--shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
--gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
font-family: 'Poppins', sans-serif;
background: var(--gradient);
min-height: 100vh;
color: var(--dark);
line-height: 1.6;
}
.container {
max-width: 1200px;
margin: 0 auto;
padding: 20px;
}
header {
background: rgba(255, 255, 255, 0.95);
border-radius: 16px;
padding: 20px;
margin-bottom: 25px;
box-shadow: var(--shadow-lg);
display: flex;
justify-content: space-between;
align-items: center;
flex-wrap: wrap;
gap: 15px;
backdrop-filter: blur(10px);
}
.logo {
display: flex;
align-items: center;
gap: 12px;
}
.logo i {
font-size: 32px;
color: var(--primary);
filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
}
.logo h1 {
font-size: 28px;
font-weight: 700;
color: var(--primary);
text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.header-actions {
display: flex;
align-items: center;
gap: 15px;
flex-wrap: wrap;
}
.search-box {
position: relative;
}
.search-box input {
padding: 12px 15px 12px 45px;
border: 2px solid var(--light-gray);
border-radius: 12px;
font-size: 15px;
width: 220px;
transition: all 0.3s ease;
background: var(--white);
}
.search-box input:focus {
outline: none;
border-color: var(--primary);
box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
}
.search-box i {
position: absolute;
left: 15px;
top: 50%;
transform: translateY(-50%);
color: var(--gray);
font-size: 16px;
}
.language-selector {
position: relative;
}
.language-btn {
background: var(--white);
border: 2px solid var(--light-gray);
border-radius: 12px;
padding: 12px 15px;
display: flex;
align-items: center;
gap: 8px;
cursor: pointer;
font-size: 15px;
transition: all 0.3s ease;
box-shadow: var(--shadow);
}
.language-btn:hover {
border-color: var(--primary);
transform: translateY(-2px);
}
.language-dropdown {
position: absolute;
top: 100%;
right: 0;
background: var(--white);
border-radius: 12px;
box-shadow: var(--shadow-lg);
z-index: 100;
min-width: 150px;
display: none;
overflow: hidden;
margin-top: 8px;
}
.language-dropdown.active {
display: block;
}
.language-option {
padding: 12px 15px;
cursor: pointer;
transition: background 0.2s ease;
display: flex;
align-items: center;
gap: 8px;
}
.language-option:hover {
background: var(--light);
}
.admin-btn {
background: var(--primary);
color: var(--white);
border: none;
border-radius: 12px;
padding: 12px 18px;
display: flex;
align-items: center;
gap: 10px;
cursor: pointer;
font-size: 15px;
font-weight: 600;
transition: all 0.3s ease;
box-shadow: var(--shadow);
}
.admin-btn:hover {
background: var(--primary-dark);
transform: translateY(-2px);
box-shadow: var(--shadow-lg);
}
.navigation {
display: flex;
gap: 15px;
width: 100%;
margin-bottom: 25px;
}
.nav-btn {
background: var(--white);
border: 2px solid var(--light-gray);
border-radius: 12px;
padding: 12px 18px;
display: flex;
align-items: center;
gap: 10px;
cursor: pointer;
font-size: 15px;
font-weight: 600;
transition: all 0.3s ease;
box-shadow: var(--shadow);
flex: 1;
justify-content: center;
}
.nav-btn:hover {
border-color: var(--primary);
transform: translateY(-2px);
}
.nav-btn.active {
background: var(--primary);
color: var(--white);
border-color: var(--primary);
}
.admin-panel {
background: rgba(255, 255, 255, 0.95);
border-radius: 16px;
padding: 25px;
margin-bottom: 25px;
box-shadow: var(--shadow-lg);
display: none;
backdrop-filter: blur(10px);
}
.admin-panel.active {
display: block;
}
.admin-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 25px;
padding-bottom: 15px;
border-bottom: 2px solid var(--light-gray);
}
.admin-title {
font-size: 24px;
font-weight: 700;
color: var(--primary);
display: flex;
align-items: center;
gap: 10px;
}
.close-admin {
background: var(--light);
border: none;
font-size: 20px;
color: var(--gray);
cursor: pointer;
width: 40px;
height: 40px;
border-radius: 50%;
display: flex;
align-items: center;
justify-content: center;
transition: all 0.3s ease;
}
.close-admin:hover {
background: var(--danger);
color: var(--white);
transform: rotate(90deg);
}
.admin-actions {
display: flex;
gap: 15px;
flex-wrap: wrap;
margin-bottom: 20px;
}
.file-input-wrapper {
position: relative;
overflow: hidden;
display: inline-block;
flex: 1;
}
.file-input-wrapper input[type=file] {
position: absolute;
left: 0;
top: 0;
opacity: 0;
cursor: pointer;
width: 100%;
height: 100%;
}
.file-input-label {
background: var(--secondary);
color: var(--white);
border-radius: 12px;
padding: 12px 18px;
display: flex;
align-items: center;
gap: 10px;
cursor: pointer;
font-size: 15px;
font-weight: 600;
transition: all 0.3s ease;
box-shadow: var(--shadow);
width: 100%;
justify-content: center;
}
.file-input-label:hover {
background: #059669;
transform: translateY(-2px);
box-shadow: var(--shadow-lg);
}
.export-btn, .save-btn {
background: var(--primary);
color: var(--white);
border: none;
border-radius: 12px;
padding: 12px 18px;
display: flex;
align-items: center;
gap: 10px;
cursor: pointer;
font-size: 15px;
font-weight: 600;
transition: all 0.3s ease;
box-shadow: var(--shadow);
flex: 1;
justify-content: center;
}
.export-btn:hover, .save-btn:hover {
background: var(--primary-dark);
transform: translateY(-2px);
box-shadow: var(--shadow-lg);
}
.save-btn {
background: var(--success);
}
.save-btn:hover {
background: #16a34a;
}
.dashboard {
background: rgba(255, 255, 255, 0.95);
border-radius: 16px;
padding: 25px;
margin-bottom: 25px;
box-shadow: var(--shadow-lg);
backdrop-filter: blur(10px);
}
.dashboard-title {
font-size: 24px;
font-weight: 700;
color: var(--primary);
margin-bottom: 25px;
display: flex;
align-items: center;
gap: 10px;
}
.dashboard-stats {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
gap: 20px;
}
.stat-card {
background: var(--white);
border-radius: 16px;
padding: 20px;
box-shadow: var(--shadow);
text-align: center;
transition: all 0.3s ease;
cursor: pointer;
border: 2px solid transparent;
}
.stat-card:hover {
transform: translateY(-5px);
box-shadow: var(--shadow-lg);
}
.stat-card.active {
border-color: var(--primary);
background: linear-gradient(135deg, rgba(37, 99, 235, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
}
.stat-icon {
font-size: 32px;
margin-bottom: 15px;
}
.stat-card.total .stat-icon {
color: var(--primary);
}
.stat-card.target .stat-icon {
color: var(--success);
}
.stat-card.close .stat-icon {
color: var(--warning);
}
.stat-card.attention .stat-icon {
color: var(--danger);
}
.stat-card.zero .stat-icon {
color: var(--danger);
}
.stat-card.average .stat-icon {
color: var(--secondary);
}
.stat-value {
font-size: 32px;
font-weight: 700;
margin-bottom: 8px;
background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
}
.stat-label {
font-size: 14px;
color: var(--gray);
font-weight: 500;
}
.table-container {
background: rgba(255, 255, 255, 0.95);
border-radius: 16px;
padding: 25px;
box-shadow: var(--shadow-lg);
overflow-x: auto;
backdrop-filter: blur(10px);
}
.table-header {
display: flex;
flex-direction: column;
gap: 15px;
margin-bottom: 25px;
padding-bottom: 15px;
border-bottom: 2px solid var(--light-gray);
}
.table-title {
font-size: 24px;
font-weight: 700;
color: var(--primary);
display: flex;
align-items: center;
gap: 10px;
}
.header-actions {
display: flex;
flex-direction: column;
gap: 15px;
}
.search-box {
width: 100%;
}
.search-box input {
width: 100%;
}
.last-updated {
font-size: 14px;
color: var(--gray);
display: flex;
align-items: center;
gap: 8px;
}
.sorting-container {
display: flex;
gap: 10px;
margin-bottom: 20px;
flex-wrap: wrap;
}
.sort-btn {
background: var(--white);
border: 2px solid var(--light-gray);
border-radius: 10px;
padding: 10px 15px;
display: flex;
align-items: center;
gap: 8px;
cursor: pointer;
font-size: 14px;
font-weight: 600;
color: var(--dark);
transition: all 0.3s ease;
box-shadow: var(--shadow);
flex: 1;
justify-content: center;
}
.sort-btn:hover {
border-color: var(--primary);
transform: translateY(-2px);
box-shadow: var(--shadow-lg);
}
.sort-btn.active {
background: var(--primary);
color: var(--white);
border-color: var(--primary);
}
.sort-btn i {
font-size: 16px;
}
table {
width: 100%;
border-collapse: collapse;
background: var(--white);
border-radius: 12px;
overflow: hidden;
box-shadow: var(--shadow);
}
th, td {
padding: 15px 20px;
text-align: left;
}
th {
background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
color: var(--white);
font-weight: 600;
position: sticky;
top: 0;
z-index: 10;
text-transform: uppercase;
font-size: 14px;
letter-spacing: 0.5px;
}
tr:nth-child(even) {
background: rgba(243, 244, 246, 0.5);
}
tr:hover {
background: rgba(229, 231, 235, 0.5);
}
.rank {
font-weight: 700;
color: var(--primary);
font-size: 18px;
}
.player {
font-weight: 600;
color: var(--dark);
}
.player.status-done {
color: var(--success);
}
.player.status-gray {
color: var(--gray);
}
.player.status-yellow {
color: var(--warning);
}
.player.status-red {
color: var(--danger);
}
.week-score {
font-weight: 600;
color: var(--dark);
}
.left-to-achieve {
font-weight: 600;
}
.status-done {
color: var(--success);
font-weight: 700;
}
.status-gray {
color: var(--gray);
font-weight: 600;
}
.status-yellow {
color: var(--warning);
font-weight: 600;
}
.status-red {
color: var(--danger);
font-weight: 600;
}
.zero-score {
color: var(--danger);
font-weight: 700;
}
.zero-score::after {
content: " ⚠️";
font-size: 16px;
}
.editable {
background: var(--white);
border: 2px solid var(--light-gray);
padding: 8px 12px;
border-radius: 8px;
width: 100%;
transition: all 0.3s ease;
font-weight: 600;
color: var(--primary);
}
.editable:focus {
outline: none;
border-color: var(--primary);
box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
}
.login-modal {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.7);
display: flex;
justify-content: center;
align-items: center;
z-index: 1000;
display: none;
backdrop-filter: blur(5px);
}
.login-modal.active {
display: flex;
}
.login-form {
background: var(--white);
border-radius: 20px;
padding: 40px;
width: 90%;
max-width: 450px;
box-shadow: var(--shadow-lg);
}
.login-title {
font-size: 28px;
font-weight: 700;
color: var(--primary);
margin-bottom: 30px;
text-align: center;
display: flex;
align-items: center;
justify-content: center;
gap: 12px;
}
.form-group {
margin-bottom: 25px;
}
.form-group label {
display: block;
margin-bottom: 10px;
font-weight: 600;
color: var(--dark);
}
.form-group input {
width: 100%;
padding: 15px 20px;
border: 2px solid var(--light-gray);
border-radius: 12px;
font-size: 16px;
transition: all 0.3s ease;
background: var(--white);
}
.form-group input:focus {
outline: none;
border-color: var(--primary);
box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
}
.login-btn {
width: 100%;
background: var(--primary);
color: var(--white);
border: none;
border-radius: 12px;
padding: 15px 20px;
font-size: 16px;
font-weight: 600;
cursor: pointer;
transition: all 0.3s ease;
box-shadow: var(--shadow);
}
.login-btn:hover {
background: var(--primary-dark);
transform: translateY(-2px);
box-shadow: var(--shadow-lg);
}
.cancel-btn {
width: 100%;
background: transparent;
color: var(--gray);
border: 2px solid var(--light-gray);
border-radius: 12px;
padding: 15px 20px;
font-size: 16px;
font-weight: 600;
cursor: pointer;
margin-top: 15px;
transition: all 0.3s ease;
}
.cancel-btn:hover {
background: var(--light);
border-color: var(--gray);
}
.notification {
position: fixed;
bottom: 30px;
right: 30px;
background: var(--white);
border-radius: 12px;
padding: 20px 25px;
box-shadow: var(--shadow-lg);
display: flex;
align-items: center;
gap: 15px;
transform: translateX(120%);
transition: transform 0.3s ease;
z-index: 1000;
max-width: 400px;
}
.notification.show {
transform: translateX(0);
}
.notification.success {
border-left: 5px solid var(--success);
}
.notification.error {
border-left: 5px solid var(--danger);
}
.notification i {
font-size: 24px;
}
.notification.success i {
color: var(--success);
}
.notification.error i {
color: var(--danger);
}
.notification-message {
font-weight: 600;
color: var(--dark);
}
.loading-indicator {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 4px;
background: var(--primary);
transform: scaleX(0);
transform-origin: left;
transition: transform 0.3s ease;
z-index: 1001;
}
.loading-indicator.active {
transform: scaleX(1);
}
.sync-status {
position: fixed;
bottom: 30px;
left: 30px;
background: rgba(0, 0, 0, 0.8);
color: white;
border-radius: 30px;
padding: 12px 20px;
font-size: 14px;
font-weight: 600;
display: none;
align-items: center;
gap: 10px;
z-index: 1000;
backdrop-filter: blur(10px);
}
.sync-status.show {
display: flex;
}
.sync-status.synced i {
color: var(--success);
}
.sync-status.syncing i {
color: var(--warning);
animation: spin 1s linear infinite;
}
.sync-status.error i {
color: var(--danger);
}
.user-info {
display: flex;
align-items: center;
gap: 12px;
background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
padding: 10px 20px;
border-radius: 30px;
font-size: 15px;
color: var(--white);
font-weight: 600;
box-shadow: var(--shadow);
}
.user-role {
font-size: 12px;
background: rgba(255, 255, 255, 0.3);
padding: 4px 10px;
border-radius: 20px;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.logout-btn {
background: rgba(255, 255, 255, 0.3);
border: none;
color: var(--white);
cursor: pointer;
font-size: 16px;
padding: 8px;
border-radius: 50%;
width: 32px;
height: 32px;
display: flex;
align-items: center;
justify-content: center;
transition: all 0.3s ease;
}
.logout-btn:hover {
background: rgba(255, 255, 255, 0.5);
transform: rotate(90deg);
}
/* Page specific styles */
.page {
display: none;
}
.page.active {
display: block;
}
/* Daily tournaments table styles */
.daily-table-container {
overflow-x: auto;
}
.daily-table {
min-width: 800px;
}
.daily-table th, .daily-table td {
padding: 12px 15px;
}
.daily-table th:first-child, .daily-table td:first-child {
position: sticky;
left: 0;
background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
color: var(--white);
z-index: 11;
}
.daily-table td:first-child {
background: var(--white);
}
.daily-table th:nth-child(2), .daily-table td:nth-child(2) {
position: sticky;
left: 80px;
background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
color: var(--white);
z-index: 11;
}
.daily-table td:nth-child(2) {
background: var(--white);
}
.daily-table th:nth-child(3), .daily-table td:nth-child(3) {
position: sticky;
left: 220px;
background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
color: var(--white);
z-index: 11;
}
.daily-table td:nth-child(3) {
background: var(--white);
}
.daily-table th:nth-child(4), .daily-table td:nth-child(4) {
position: sticky;
left: 320px;
background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
color: var(--white);
z-index: 11;
}
.daily-table td:nth-child(4) {
background: var(--white);
}
/* MODIFICATIONS START */
/* Make date columns wider to accommodate at least 2 digits */
.daily-table td:not(:nth-child(-n+4)) {
    min-width: 40px;
    max-width: 60px;
}

/* Style for player name when any score is 0 */
.player-name.has-zero {
    color: var(--danger) !important;
    font-weight: 700;
}

/* Style for zero values in cells */
.zero-value {
    background-color: rgba(239, 68, 68, 0.2) !important;
    color: var(--danger) !important;
    font-weight: 700;
}
.zero-value::after {
    content: " ⚠️";
}

/* Mobile modification: Double the width of date columns */
@media (max-width: 768px) {
    .daily-table td:not(:nth-child(-n+4)) {
        min-width: 80px !important;
        max-width: 100px !important;
    }
    
    /* Ensure input fields take the full width of the cell */
    .daily-table td:not(:nth-child(-n+4)) input.editable {
        width: 100% !important;
        min-width: 70px !important;
    }
}
/* MODIFICATIONS END */

/* Adăugăm stiluri pentru celulele din tabelul zilnic pentru a asigura vizibilitatea textului */
.daily-table td {
    color: var(--dark) !important;
}
.daily-table input.editable {
    color: var(--primary) !important;
}
/* Dashboard buttons for daily tournaments */
.daily-dashboard-stats {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
gap: 20px;
}
@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}
@media (max-width: 768px) {
.container {
padding: 15px;
}
header {
flex-direction: column;
align-items: flex-start;
}
.header-actions {
width: 100%;
justify-content: space-between;
}
.search-box input {
width: 150px;
}
.dashboard-stats, .daily-dashboard-stats {
grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
gap: 15px;
}
.stat-card {
padding: 10px;
}
.stat-icon {
font-size: 20px;
margin-bottom: 8px;
}
.stat-value {
font-size: 20px;
margin-bottom: 5px;
}
.stat-label {
font-size: 12px;
}
.table-container {
padding: 15px;
}
th, td {
padding: 12px 15px;
font-size: 14px;
}
.notification {
bottom: 20px;
right: 20px;
left: 20px;
max-width: none;
}
.sorting-container {
flex-direction: column;
}
.sort-btn {
width: 100%;
justify-content: center;
}
.navigation {
flex-direction: column;
}
.nav-btn {
width: 100%;
}
.admin-actions {
flex-direction: column;
}
.file-input-wrapper, .export-btn, .save-btn {
width: 100%;
}
}
</style>
</head>
<body>
<div class="loading-indicator" id="loadingIndicator"></div>
<div class="sync-status synced" id="syncStatus">
<i class="fas fa-check-circle"></i>
<span>Synced</span>
</div>
<div class="container">
<header>
<div class="logo">
<i class="fas fa-trophy"></i>
<h1 data-i18n="appTitle">Scoring System</h1>
</div>
<div class="header-actions">
<div class="search-box">
<i class="fas fa-search"></i>
<input type="text" id="searchInput" placeholder="Search players..." data-i18n-placeholder="searchPlaceholder">
</div>
<div class="language-selector">
<div class="language-btn" id="languageBtn">
<i class="fas fa-globe"></i>
<span id="currentLang">RO</span>
<i class="fas fa-chevron-down"></i>
</div>
<div class="language-dropdown" id="languageDropdown">
<div class="language-option" data-lang="ro">
<i class="fas fa-flag"></i>
<span>Română</span>
</div>
<div class="language-option" data-lang="en">
<i class="fas fa-flag"></i>
<span>English</span>
</div>
<div class="language-option" data-lang="es">
<i class="fas fa-flag"></i>
<span>Español</span>
</div>
</div>
</div>
<div class="user-info" id="userInfo" style="display: none;">
<i class="fas fa-user"></i>
<span id="userName"></span>
<span class="user-role" id="userRole"></span>
<button class="logout-btn" id="logoutBtn">
<i class="fas fa-sign-out-alt"></i>
</button>
</div>
<button class="admin-btn" id="adminBtn">
<i class="fas fa-user-shield"></i>
<span data-i18n="adminPanel">Admin Panel</span>
</button>
</div>
</header>
<div class="navigation">
<button class="nav-btn active" id="mainPageBtn">
<i class="fas fa-trophy"></i>
<span data-i18n="mainPage">Main Page</span>
</button>
<button class="nav-btn" id="dailyTournamentsBtn">
<i class="fas fa-calendar-day"></i>
<span data-i18n="dailyTournaments">Daily Tournaments</span>
</button>
</div>
<!-- Main Page -->
<div id="mainPage" class="page active">
<div class="admin-panel" id="adminPanel">
<div class="admin-header">
<h2 class="admin-title">
<i class="fas fa-cogs"></i>
<span data-i18n="adminPanel">Admin Panel</span>
</h2>
<button class="close-admin" id="closeAdmin">
<i class="fas fa-times"></i>
</button>
</div>
<div class="admin-actions">
<div class="file-input-wrapper" id="importWrapper">
<input type="file" id="fileInput" accept=".xlsx, .xls">
<label for="fileInput" class="file-input-label">
<i class="fas fa-file-excel"></i>
<span data-i18n="importExcel">Import Excel</span>
</label>
</div>
<button class="export-btn" id="exportBtn">
<i class="fas fa-download"></i>
<span data-i18n="exportData">Export Data</span>
</button>
<button class="save-btn" id="saveBtn">
<i class="fas fa-save"></i>
<span data-i18n="saveData">Save Data</span>
</button>
</div>
</div>
<div class="dashboard">
<h2 class="dashboard-title">
<i class="fas fa-chart-line"></i>
<span data-i18n="dashboard">Dashboard</span>
</h2>
<div class="dashboard-stats">
<div class="stat-card total" data-filter="all">
<div class="stat-icon">
<i class="fas fa-users"></i>
</div>
<div class="stat-value" id="totalPlayers">0</div>
<div class="stat-label" data-i18n="totalPlayers">Total Players</div>
</div>
<div class="stat-card target" data-filter="target">
<div class="stat-icon">
<i class="fas fa-check-circle"></i>
</div>
<div class="stat-value" id="targetAchieved">0</div>
<div class="stat-label" data-i18n="targetAchieved">Target Achieved</div>
</div>
<div class="stat-card close" data-filter="close">
<div class="stat-icon">
<i class="fas fa-hourglass-half"></i>
</div>
<div class="stat-value" id="closeToTarget">0</div>
<div class="stat-label" data-i18n="closeToTarget">Close to Target</div>
</div>
<div class="stat-card attention" data-filter="attention">
<div class="stat-icon">
<i class="fas fa-exclamation-triangle"></i>
</div>
<div class="stat-value" id="attentionNeeded">0</div>
<div class="stat-label" data-i18n="attentionNeeded">Attention Needed</div>
</div>
<div class="stat-card zero" data-filter="zero">
<div class="stat-icon">
<i class="fas fa-times-circle"></i>
</div>
<div class="stat-value" id="zeroPoints">0</div>
<div class="stat-label" data-i18n="zeroPoints">Zero Points</div>
</div>
<div class="stat-card average">
<div class="stat-icon">
<i class="fas fa-chart-bar"></i>
</div>
<div class="stat-value" id="weeklyAverage">0</div>
<div class="stat-label" data-i18n="weeklyAverage">Weekly Average</div>
</div>
</div>
</div>
<div class="table-container">
<div class="table-header">
<h2 class="table-title">
<i class="fas fa-trophy"></i>
<span data-i18n="ranking">Ranking</span>
</h2>
<div class="last-updated" id="lastUpdated">
<i class="fas fa-clock"></i>
<span data-i18n="lastUpdated">Last updated:</span>
<span id="updateTime">Never</span>
</div>
</div>
<div class="sorting-container">
<button class="sort-btn active" data-sort="rank">
<i class="fas fa-sort-numeric-down"></i>
<span data-i18n="sortByRank">Sort by Rank</span>
</button>
<button class="sort-btn" data-sort="name">
<i class="fas fa-sort-alpha-down"></i>
<span data-i18n="sortByName">Sort by Name</span>
</button>
<button class="sort-btn" data-sort="score">
<i class="fas fa-sort-numeric-down-alt"></i>
<span data-i18n="sortByScore">Sort by Score</span>
</button>
</div>
<table id="rankingTable">
<thead>
<tr>
<th data-i18n="rank">Rank</th>
<th data-i18n="player">Player</th>
<th data-i18n="totalScores">Total Scores</th>
<th data-i18n="weekScore">Week Score</th>
<th data-i18n="leftToAchieve">Left to Achieve</th>
</tr>
</thead>
<tbody id="rankingBody">
<!-- Table rows will be generated here -->
</tbody>
</table>
</div>
</div>
</div>
<!-- Daily Tournaments Page -->
<div id="dailyTournamentsPage" class="page">
<div class="admin-panel" id="dailyAdminPanel">
<div class="admin-header">
<h2 class="admin-title">
<i class="fas fa-cogs"></i>
<span data-i18n="adminPanel">Admin Panel</span>
</h2>
<button class="close-admin" id="closeDailyAdmin">
<i class="fas fa-times"></i>
</button>
</div>
<div class="admin-actions">
<div class="file-input-wrapper" id="dailyImportWrapper">
<input type="file" id="dailyFileInput" accept=".xlsx, .xls">
<label for="dailyFileInput" class="file-input-label">
<i class="fas fa-file-excel"></i>
<span data-i18n="importPlayers">Import Players</span>
</label>
</div>
<button class="export-btn" id="dailyExportBtn">
<i class="fas fa-download"></i>
<span data-i18n="exportDailyData">Export Daily Data</span>
</button>
<button class="save-btn" id="dailySaveBtn">
<i class="fas fa-save"></i>
<span data-i18n="saveDailyData">Save Daily Data</span>
</button>
</div>
</div>
<div class="dashboard">
<h2 class="dashboard-title">
<i class="fas fa-chart-line"></i>
<span data-i18n="dailyDashboard">Daily Tournaments Dashboard</span>
</h2>
<div class="daily-dashboard-stats">
<div class="stat-card total" data-daily-filter="all">
<div class="stat-icon">
<i class="fas fa-users"></i>
</div>
<div class="stat-value" id="dailyTotalPlayers">0</div>
<div class="stat-label" data-i18n="totalPlayers">Total Players</div>
</div>
<div class="stat-card target" data-daily-filter="top10">
<div class="stat-icon">
<i class="fas fa-trophy"></i>
</div>
<div class="stat-value" id="top10Players">0</div>
<div class="stat-label" data-i18n="top10Players">Top 10 Players</div>
</div>
<div class="stat-card close" data-daily-filter="top32">
<div class="stat-icon">
<i class="fas fa-medal"></i>
</div>
<div class="stat-value" id="top32Players">0</div>
<div class="stat-label" data-i18n="top32Players">Top 32 Players</div>
</div>
<div class="stat-card attention" data-daily-filter="missed">
<div class="stat-icon">
<i class="fas fa-times-circle"></i>
</div>
<div class="stat-value" id="missedTournaments">0</div>
<div class="stat-label" data-i18n="missedTournaments">Missed Tournaments</div>
</div>
<div class="stat-card zero" data-daily-filter="min2missed">
<div class="stat-icon">
<i class="fas fa-exclamation-triangle"></i>
</div>
<div class="stat-value" id="min2Missed">0</div>
<div class="stat-label" data-i18n="min2Missed">Min 2 Missed</div>
</div>
</div>
</div>
<div class="table-container">
<div class="table-header">
<h2 class="table-title">
<i class="fas fa-calendar-day"></i>
<span data-i18n="dailyTournaments">Daily Tournaments</span>
</h2>
<div class="header-actions">
<div class="search-box">
<i class="fas fa-search"></i>
<input type="text" id="dailySearchInput" placeholder="Search players..." data-i18n-placeholder="searchPlaceholder">
</div>
<div class="last-updated" id="dailyLastUpdated">
<i class="fas fa-clock"></i>
<span data-i18n="lastUpdated">Last updated:</span>
<span id="dailyUpdateTime">Never</span>
</div>
</div>
</div>
<div class="sorting-container">
<button class="sort-btn active" data-daily-sort="rank">
<i class="fas fa-sort-numeric-down"></i>
<span data-i18n="sortByRank">Sort by Rank</span>
</button>
<button class="sort-btn" data-daily-sort="name">
<i class="fas fa-sort-alpha-down"></i>
<span data-i18n="sortByName">Sort by Name</span>
</button>
</div>
<div class="daily-table-container">
<table id="dailyTournamentsTable" class="daily-table">
<thead>
<tr>
<th data-i18n="rank">Rank</th>
<th data-i18n="playerName">Player Name</th>
<th data-i18n="average">Average</th>
<th data-i18n="nrTournaments">Nr. Tournament</th>
<!-- Daily columns will be generated here -->
</tr>
</thead>
<tbody id="dailyTournamentsBody">
<!-- Table rows will be generated here -->
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="login-modal" id="loginModal">
<div class="login-form">
<h2 class="login-title">
<i class="fas fa-user-shield"></i>
<span data-i18n="adminLogin">Login</span>
</h2>
<div class="form-group">
<label for="username" data-i18n="username">Username</label>
<input type="text" id="username" placeholder="Enter username...">
</div>
<div class="form-group">
<label for="password" data-i18n="password">Password</label>
<input type="password" id="password" placeholder="Enter password...">
</div>
<button class="login-btn" id="loginBtn" data-i18n="login">Login</button>
<button class="cancel-btn" id="cancelLogin" data-i18n="cancel">Cancel</button>
</div>
</div>
<div class="notification" id="notification">
<i class="fas fa-check-circle"></i>
<div class="notification-message" id="notificationMessage"></div>
</div>
<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script>
// Translation data
const translations = {
ro: {
appTitle: "Sistem de Punctaj",
searchPlaceholder: "Caută jucători...",
adminPanel: "Panou Admin",
importExcel: "Import Excel",
exportData: "Export Date",
saveData: "Salvează Date",
dashboard: "Panou",
totalPlayers: "Total Jucători",
targetAchieved: "Target Atins",
closeToTarget: "Aproape de Target",
attentionNeeded: "Atenție",
zeroPoints: "0 Puncte",
weeklyAverage: "Media Săptămânii",
ranking: "Clasament",
lastUpdated: "Ultima actualizare:",
rank: "Poziție",
player: "Jucător",
totalScores: "Punctaj Total",
weekScore: "Punctaj Săptămână",
leftToAchieve: "Până la Target",
adminLogin: "Autentificare",
password: "Parolă",
username: "Utilizator",
login: "Autentificare",
cancel: "Anulează",
dataSaved: "Date salvate cu succes!",
dataLoaded: "Date încărcate cu succes!",
loginSuccess: "Autentificare reușită!",
loginError: "Utilizator sau parolă incorectă!",
exportSuccess: "Date exportate cu succes!",
importSuccess: "Date importate cu succes!",
noDataFound: "Nu s-au găcut date salvate. Se încarcă date de test.",
never: "Niciodată",
minutes: "minute",
hours: "ore",
days: "zile",
done: "Realizat",
logoutSuccess: "Deconectare reușită!",
sortByRank: "Sortare după poziție",
sortByName: "Sortare după nume",
sortByScore: "Sortare după punctaj",
mainPage: "Pagina Principală",
dailyTournaments: "Turnee Zilnice",
importPlayers: "Import Jucători",
exportDailyData: "Export Date Zilnice",
saveDailyData: "Salvează Date Zilnice",
dailyDashboard: "Panou Turnee Zilnice",
top10Players: "Top 10 Jucători",
top32Players: "Top 32 Jucători",
missedTournaments: "Turnee Ratate",
min2Missed: "Minim 2 Ratate",
playerName: "Nume Jucător",
average: "Medie",
nrTournaments: "Nr. Turnee"
},
en: {
appTitle: "Scoring System",
searchPlaceholder: "Search players...",
adminPanel: "Admin Panel",
importExcel: "Import Excel",
exportData: "Export Data",
saveData: "Save Data",
dashboard: "Dashboard",
totalPlayers: "Total Players",
targetAchieved: "Target Achieved",
closeToTarget: "Close to Target",
attentionNeeded: "Attention Needed",
zeroPoints: "Zero Points",
weeklyAverage: "Weekly Average",
ranking: "Ranking",
lastUpdated: "Last updated:",
rank: "Rank",
player: "Player",
totalScores: "Total Scores",
weekScore: "Week Score",
leftToAchieve: "Left to Achieve",
adminLogin: "Login",
password: "Password",
username: "Username",
login: "Login",
cancel: "Cancel",
dataSaved: "Data saved successfully!",
dataLoaded: "Data loaded successfully!",
loginSuccess: "Login successful!",
loginError: "Incorrect username or password!",
exportSuccess: "Data exported successfully!",
importSuccess: "Data imported successfully!",
noDataFound: "No saved data found. Loading test data.",
never: "Never",
minutes: "minutes",
hours: "hours",
days: "days",
done: "Done",
logoutSuccess: "Logout successful!",
sortByRank: "Sort by Rank",
sortByName: "Sort by Name",
sortByScore: "Sort by Score",
mainPage: "Main Page",
dailyTournaments: "Daily Tournaments",
importPlayers: "Import Players",
exportDailyData: "Export Daily Data",
saveDailyData: "Save Daily Data",
dailyDashboard: "Daily Tournaments Dashboard",
top10Players: "Top 10 Players",
top32Players: "Top 32 Players",
missedTournaments: "Missed Tournaments",
min2Missed: "Min 2 Missed",
playerName: "Player Name",
average: "Average",
nrTournaments: "Nr. Tournament"
},
es: {
appTitle: "Sistema de Puntuación",
searchPlaceholder: "Buscar jugadores...",
adminPanel: "Panel de Admin",
importExcel: "Importar Excel",
exportData: "Exportar Datos",
saveData: "Guardar Datos",
dashboard: "Panel de Control",
totalPlayers: "Total Jugadores",
targetAchieved: "Objetivo Alcanzado",
closeToTarget: "Cerca del Objetivo",
attentionNeeded: "Atención Requerida",
zeroPoints: "Cero Puntos",
weeklyAverage: "Promedio Semanal",
ranking: "Clasificación",
lastUpdated: "Última actualización:",
rank: "Rango",
player: "Jugador",
totalScores: "Puntuación Total",
weekScore: "Puntuación Semanal",
leftToAchieve: "Restante para Objetivo",
adminLogin: "Inicio de Sesión",
password: "Contraseña",
username: "Usuario",
login: "Iniciar Sesión",
cancel: "Cancelar",
dataSaved: "¡Datos guardados con éxito!",
dataLoaded: "¡Datos cargados con éxito!",
loginSuccess: "¡Inicio de sesión exitoso!",
loginError: "¡Usuario o contraseña incorrectos!",
exportSuccess: "¡Datos exportados con éxito!",
importSuccess: "¡Datos importados con éxito!",
noDataFound: "No se encontraron datos guardados. Cargando datos de prueba.",
never: "Nunca",
minutes: "minutos",
hours: "horas",
days: "días",
done: "Hecho",
logoutSuccess: "¡Cierre de sesión exitoso!",
sortByRank: "Ordenar por Rango",
sortByName: "Ordenar por Nombre",
sortByScore: "Ordenar por Puntuación",
mainPage: "Página Principal",
dailyTournaments: "Torneos Diarios",
importPlayers: "Importar Jugadores",
exportDailyData: "Exportar Datos Diarios",
saveDailyData: "Guardar Datos Diarios",
dailyDashboard: "Panel de Torneos Diarios",
top10Players: "Top 10 Jugadores",
top32Players: "Top 32 Jugadores",
missedTournaments: "Torneos Perdidos",
min2Missed: "Mínimo 2 Perdidos",
playerName: "Nombre del Jugador",
average: "Promedio",
nrTournaments: "Nr. Torneo"
}
};
// Firebase Configuration
const firebaseConfig = {
apiKey: "AIzaSyAg-8kByVcC4gh1FEuZJvnhs525nQShixA",
authDomain: "diaspora-romana-15c53.firebaseapp.com",
databaseURL: "https://diaspora-romana-15c53-default-rtdb.europe-west1.firebasedatabase.app",
projectId: "diaspora-romana-15c53",
storageBucket: "diaspora-romana-15c53.firebasestorage.app",
messagingSenderId: "983580221213",
appId: "1:983580221213:web:d9f4b82f8acb7ec47f8bf4",
measurementId: "G-HHCTDB7CFS"
};
// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const database = firebase.database();
// Application state
let currentLang = 'ro';
let currentUser = null;
let userRole = null;
let players = [];
let dailyPlayers = [];
let lastUpdateTime = null;
let dailyLastUpdateTime = null;
let activeFilter = 'all';
let dailyActiveFilter = 'all';
let searchQuery = '';
let dailySearchQuery = '';
let isSyncing = false;
let syncTimeout = null;
let currentSortMethod = 'rank';
let dailyCurrentSortMethod = 'rank';
let activePage = 'mainPage';
// Default users
const defaultUsers = [
{ username: 'admin', password: 'diasporaromana123', role: 'admin' },
{ username: 'editor', password: 'fcmobile', role: 'editor' }
];
// DOM elements
const elements = {};
// Cache DOM elements
function cacheElements() {
const elementIds = [
'languageBtn', 'languageDropdown', 'adminBtn', 'adminPanel',
'closeAdmin', 'fileInput', 'exportBtn', 'saveBtn', 'loginModal',
'loginBtn', 'cancelLogin', 'password', 'notification',
'notificationMessage', 'searchInput', 'rankingBody', 'updateTime',
'totalPlayers', 'targetAchieved', 'closeToTarget',
'attentionNeeded', 'zeroPoints', 'weeklyAverage',
'currentLang', 'loadingIndicator', 'syncStatus', 'userInfo',
'userName', 'userRole', 'logoutBtn', 'username', 'importWrapper',
'mainPageBtn', 'dailyTournamentsBtn', 'mainPage', 'dailyTournamentsPage',
'dailyAdminPanel', 'closeDailyAdmin', 'dailyFileInput', 'dailyExportBtn',
'dailySaveBtn', 'dailyImportWrapper', 'dailyTournamentsBody', 'dailyUpdateTime',
'dailyTotalPlayers', 'top10Players', 'top32Players', 'missedTournaments', 'min2Missed',
'dailySearchInput'
];
elementIds.forEach(id => {
const element = document.getElementById(id);
if (element) {
elements[id] = element;
}
});
// Cache elements by class
elements.languageOptions = document.querySelectorAll('.language-option');
elements.statCards = document.querySelectorAll('.stat-card');
elements.dailyStatCards = document.querySelectorAll('[data-daily-filter]');
elements.sortButtons = document.querySelectorAll('.sort-btn');
elements.dailySortButtons = document.querySelectorAll('[data-daily-sort]');
}
// Initialize app
function initApp() {
cacheElements();
loadLanguage();
setupEventListeners();
setupSortButtons();
checkLoginStatus();
loadDataFromFirebase();
loadDailyDataFromFirebase();
// Set up periodic sync status check
setInterval(() => {
if (isSyncing) {
updateSyncStatus('syncing');
} else {
updateSyncStatus('synced');
}
}, 5000);
// Check for daily columns generation
checkDailyColumns();
// Set up daily column generation at midnight
setupMidnightColumnGeneration();
}
// Setup midnight column generation
function setupMidnightColumnGeneration() {
const now = new Date();
const night = new Date(
now.getFullYear(),
now.getMonth(),
now.getDate() + 1, // the next day
0, 0, 0 // at 00:00:00 hours
);
const msToMidnight = night.getTime() - now.getTime();
setTimeout(() => {
generateDailyColumn();
// Set up daily generation
setInterval(generateDailyColumn, 24 * 60 * 60 * 1000); // every 24 hours
}, msToMidnight);
}
// Generate daily column
function generateDailyColumn() {
const today = new Date();
const formattedDate = formatDate(today);
// Check if column already exists
const existingColumn = document.querySelector(`th[data-date="${formattedDate}"]`);
if (!existingColumn) {
// Add new column to header (after the first 4 columns)
const headerRow = document.querySelector('#dailyTournamentsTable thead tr');
const newHeader = document.createElement('th');
newHeader.setAttribute('data-date', formattedDate);
newHeader.textContent = formattedDate;
        
// Insert after the 4th column (index 3)
if (headerRow.children.length > 3) {
headerRow.insertBefore(newHeader, headerRow.children[4]);
} else {
headerRow.appendChild(newHeader);
}
        
// Add new column to each player row
const rows = document.querySelectorAll('#dailyTournamentsBody tr');
rows.forEach(row => {
const newCell = document.createElement('td');
newCell.setAttribute('data-date', formattedDate);
const playerName = row.querySelector('.player-name').textContent;
const player = dailyPlayers.find(p => p.playerName === playerName);
if (player && player.scores && player.scores[formattedDate] !== undefined) {
const score = player.scores[formattedDate];
if (score === 0) {
newCell.classList.add('zero-value');
}
newCell.innerHTML = `<input type="number" class="editable" value="${score}" 
onchange="updateDailyScore('${playerName}', '${formattedDate}', this.value)">`;
} else {
newCell.innerHTML = `<input type="number" class="editable" value="" 
onchange="updateDailyScore('${playerName}', '${formattedDate}', this.value)">`;
}
            
// Insert after the 4th column (index 3)
if (row.children.length > 3) {
row.insertBefore(newCell, row.children[4]);
} else {
row.appendChild(newCell);
}
});
        
// Update player data structure
dailyPlayers.forEach(player => {
if (!player.scores) {
player.scores = {};
}
if (player.scores[formattedDate] === undefined) {
player.scores[formattedDate] = null;
}
});
        
// Save updated data
saveDailyDataToFirebase();
showNotification(`New column added for ${formattedDate}`, 'success');
}
}
// Check and generate missing daily columns
function checkDailyColumns() {
const startDate = new Date('2025-09-01');
const today = new Date();
const headerRow = document.querySelector('#dailyTournamentsTable thead tr');
if (!headerRow) return;
    
// Clear existing date columns (keep first 4 columns)
while (headerRow.children.length > 4) {
headerRow.removeChild(headerRow.lastChild);
}
    
// Generate columns from today to start date (reverse order)
for (let d = new Date(today); d >= startDate; d.setDate(d.getDate() - 1)) {
const formattedDate = formatDate(d);
const newHeader = document.createElement('th');
newHeader.setAttribute('data-date', formattedDate);
newHeader.textContent = formattedDate;
headerRow.appendChild(newHeader);
}
    
// Update player data structure
dailyPlayers.forEach(player => {
if (!player.scores) {
player.scores = {};
}
for (let d = new Date(startDate); d <= today; d.setDate(d.getDate() + 1)) {
const dateStr = formatDate(new Date(d));
if (player.scores[dateStr] === undefined) {
player.scores[dateStr] = null;
}
}
});
    
// Re-render the table
renderDailyTable();
}
// Format date as DD-MM-YYYY
function formatDate(date) {
const day = String(date.getDate()).padStart(2, '0');
const month = String(date.getMonth() + 1).padStart(2, '0');
const year = date.getFullYear();
return `${day}-${month}-${year}`;
}
// Check login status from localStorage
function checkLoginStatus() {
const savedUser = localStorage.getItem('currentUser');
const savedRole = localStorage.getItem('userRole');
if (savedUser && savedRole) {
currentUser = savedUser;
userRole = savedRole;
updateUIForLoggedInUser();
}
}
// Update admin panel visibility based on user role
function updateAdminPanelVisibility() {
// Verificăm dacă utilizatorul este autentificat
const isLoggedIn = currentUser && (userRole === 'admin' || userRole === 'editor');
    
    // Panoul de administrare pentru pagina principală
    if (elements.importWrapper) {
        elements.importWrapper.style.display = isLoggedIn && userRole === 'admin' ? 'block' : 'none';
    }
    if (elements.exportBtn) {
        elements.exportBtn.style.display = isLoggedIn ? 'block' : 'none';
    }
    if (elements.saveBtn) {
        elements.saveBtn.style.display = isLoggedIn ? 'block' : 'none';
    }
    
    // Panoul de administrare pentru pagina de turnee zilnice
    if (elements.dailyImportWrapper) {
        elements.dailyImportWrapper.style.display = isLoggedIn && userRole === 'admin' ? 'block' : 'none';
    }
    if (elements.dailyExportBtn) {
        elements.dailyExportBtn.style.display = isLoggedIn ? 'block' : 'none';
    }
    if (elements.dailySaveBtn) {
        elements.dailySaveBtn.style.display = isLoggedIn ? 'block' : 'none';
    }
    
    // Asigurăm că panoul de administrare este vizibil pentru utilizatorii autentificați
    if (isLoggedIn) {
        if (activePage === 'mainPage' && elements.adminPanel) {
            elements.adminPanel.classList.add('active');
        } else if (activePage === 'dailyTournamentsPage' && elements.dailyAdminPanel) {
            elements.dailyAdminPanel.classList.add('active');
        }
    }
}
// Setup event listeners
function setupEventListeners() {
// Language selector
if (elements.languageBtn) {
elements.languageBtn.addEventListener('click', () => {
if (elements.languageDropdown) {
elements.languageDropdown.classList.toggle('active');
}
});
}
if (elements.languageOptions) {
elements.languageOptions.forEach(option => {
option.addEventListener('click', () => {
const lang = option.getAttribute('data-lang');
changeLanguage(lang);
if (elements.languageDropdown) {
elements.languageDropdown.classList.remove('active');
}
});
});
}
// Admin panel
if (elements.adminBtn) {
elements.adminBtn.addEventListener('click', () => {
if (currentUser) {
if (activePage === 'mainPage' && elements.adminPanel) {
elements.adminPanel.classList.toggle('active');
} else if (activePage === 'dailyTournamentsPage' && elements.dailyAdminPanel) {
elements.dailyAdminPanel.classList.toggle('active');
}
// Actualizăm vizibilitatea butoanelor la deschiderea panoului
updateAdminPanelVisibility();
} else {
if (elements.loginModal) {
elements.loginModal.classList.add('active');
}
}
});
}
if (elements.closeAdmin) {
elements.closeAdmin.addEventListener('click', () => {
if (elements.adminPanel) {
elements.adminPanel.classList.remove('active');
}
});
}
if (elements.closeDailyAdmin) {
elements.closeDailyAdmin.addEventListener('click', () => {
if (elements.dailyAdminPanel) {
elements.dailyAdminPanel.classList.remove('active');
}
});
}
// Login
if (elements.loginBtn) {
elements.loginBtn.addEventListener('click', () => {
const username = elements.username ? elements.username.value : '';
const password = elements.password ? elements.password.value : '';
const user = defaultUsers.find(u => u.username === username && u.password === password);
if (user) {
currentUser = user.username;
userRole = user.role;
// Save to localStorage
localStorage.setItem('currentUser', currentUser);
localStorage.setItem('userRole', userRole);
if (elements.loginModal) {
elements.loginModal.classList.remove('active');
}
updateUIForLoggedInUser();
showNotification(translations[currentLang].loginSuccess, 'success');
if (elements.password) {
elements.password.value = '';
}
if (elements.username) {
elements.username.value = '';
}
} else {
showNotification(translations[currentLang].loginError, 'error');
}
});
}
if (elements.cancelLogin) {
elements.cancelLogin.addEventListener('click', () => {
if (elements.loginModal) {
elements.loginModal.classList.remove('active');
}
if (elements.password) {
elements.password.value = '';
}
if (elements.username) {
elements.username.value = '';
}
});
}
// Logout
if (elements.logoutBtn) {
elements.logoutBtn.addEventListener('click', () => {
currentUser = null;
userRole = null;
localStorage.removeItem('currentUser');
localStorage.removeItem('userRole');
updateUIForLoggedOutUser();
showNotification(translations[currentLang].logoutSuccess, 'success');
});
}
// File import
if (elements.fileInput) {
elements.fileInput.addEventListener('change', handleFileImport);
}
// Daily file import
if (elements.dailyFileInput) {
elements.dailyFileInput.addEventListener('change', handleDailyFileImport);
}
// Export
if (elements.exportBtn) {
elements.exportBtn.addEventListener('click', exportData);
}
// Daily export
if (elements.dailyExportBtn) {
elements.dailyExportBtn.addEventListener('click', exportDailyData);
}
// Save
if (elements.saveBtn) {
elements.saveBtn.addEventListener('click', saveDataToFirebase);
}
// Daily save
if (elements.dailySaveBtn) {
elements.dailySaveBtn.addEventListener('click', saveDailyDataToFirebase);
}
// Search
if (elements.searchInput) {
elements.searchInput.addEventListener('input', (e) => {
searchQuery = e.target.value.toLowerCase();
renderTable();
});
}
// Daily search
if (elements.dailySearchInput) {
elements.dailySearchInput.addEventListener('input', (e) => {
dailySearchQuery = e.target.value.toLowerCase();
renderDailyTable();
});
}
// Dashboard filters
if (elements.statCards) {
elements.statCards.forEach(card => {
card.addEventListener('click', () => {
const filter = card.getAttribute('data-filter');
setActiveFilter(filter);
});
});
}
// Daily dashboard filters
if (elements.dailyStatCards) {
elements.dailyStatCards.forEach(card => {
card.addEventListener('click', () => {
const filter = card.getAttribute('data-daily-filter');
setDailyActiveFilter(filter);
});
});
}
// Navigation
if (elements.mainPageBtn) {
elements.mainPageBtn.addEventListener('click', () => {
showPage('mainPage');
});
}
if (elements.dailyTournamentsBtn) {
elements.dailyTournamentsBtn.addEventListener('click', () => {
showPage('dailyTournamentsPage');
});
}
// Close dropdowns when clicking outside
document.addEventListener('click', (e) => {
if (!e.target.closest('.language-selector') && elements.languageDropdown) {
elements.languageDropdown.classList.remove('active');
}
});
}
// Setup sort buttons
function setupSortButtons() {
// Main page sort buttons
if (elements.sortButtons) {
elements.sortButtons.forEach(button => {
button.addEventListener('click', () => {
// Remove active class from all buttons
elements.sortButtons.forEach(btn => btn.classList.remove('active'));
// Add active class to clicked button
button.classList.add('active');
// Update sort method
currentSortMethod = button.getAttribute('data-sort');
// Re-render table with new sort
renderTable();
});
});
}
// Daily page sort buttons
if (elements.dailySortButtons) {
elements.dailySortButtons.forEach(button => {
button.addEventListener('click', () => {
// Remove active class from all buttons
elements.dailySortButtons.forEach(btn => btn.classList.remove('active'));
// Add active class to clicked button
button.classList.add('active');
// Update sort method
dailyCurrentSortMethod = button.getAttribute('data-daily-sort');
// Re-render table with new sort
renderDailyTable();
});
});
}
}
// Show page
function showPage(pageId) {
// Hide all pages
document.querySelectorAll('.page').forEach(page => {
page.classList.remove('active');
});
// Show selected page
const page = document.getElementById(pageId);
if (page) {
page.classList.add('active');
}
activePage = pageId;
// Update navigation buttons
if (elements.mainPageBtn) {
elements.mainPageBtn.classList.toggle('active', pageId === 'mainPage');
}
if (elements.dailyTournamentsBtn) {
elements.dailyTournamentsBtn.classList.toggle('active', pageId === 'dailyTournamentsPage');
}
// Update admin panel visibility
updateAdminPanelVisibility();
}
// Update UI for logged in user
function updateUIForLoggedInUser() {
if (elements.userInfo) {
elements.userInfo.style.display = 'flex';
}
if (elements.userName) {
elements.userName.textContent = currentUser;
}
if (elements.userRole) {
elements.userRole.textContent = userRole;
}
if (elements.adminBtn) {
elements.adminBtn.style.display = 'none';
}
    
    // Afișăm panoul de administrare corespunzător paginii active
    if (userRole === 'admin' || userRole === 'editor') {
        if (activePage === 'mainPage' && elements.adminPanel) {
            elements.adminPanel.classList.add('active');
        } else if (activePage === 'dailyTournamentsPage' && elements.dailyAdminPanel) {
            elements.dailyAdminPanel.classList.add('active');
        }
    }
    
    // Actualizăm vizibilitatea butoanelor de administrare
    updateAdminPanelVisibility();
    
    renderTable();
    renderDailyTable();
}
// Update UI for logged out user
function updateUIForLoggedOutUser() {
if (elements.userInfo) {
elements.userInfo.style.display = 'none';
}
if (elements.adminBtn) {
elements.adminBtn.style.display = 'flex';
}
if (elements.adminPanel) {
elements.adminPanel.classList.remove('active');
}
if (elements.dailyAdminPanel) {
elements.dailyAdminPanel.classList.remove('active');
}
    
    // Actualizăm vizibilitatea butoanelor de administrare
    updateAdminPanelVisibility();
    
    renderTable();
    renderDailyTable();
}
// Language functions
function changeLanguage(lang) {
currentLang = lang;
if (elements.currentLang) {
elements.currentLang.textContent = lang.toUpperCase();
}
loadLanguage();
updateDashboard();
updateDailyDashboard();
renderTable();
renderDailyTable();
updateLastUpdatedTime();
updateDailyLastUpdatedTime();
}
function loadLanguage() {
// Update all elements with data-i18n attribute
document.querySelectorAll('[data-i18n]').forEach(element => {
const key = element.getAttribute('data-i18n');
if (translations[currentLang] && translations[currentLang][key]) {
element.textContent = translations[currentLang][key];
} else if (translations['ro'] && translations['ro'][key]) {
// Fallback to Romanian if translation is missing
element.textContent = translations['ro'][key];
console.warn(`Missing translation for key "${key}" in language "${currentLang}", using Romanian`);
} else {
console.error(`Missing translation for key "${key}" in all languages`);
}
});
// Update all elements with data-i18n-placeholder attribute
document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
const key = element.getAttribute('data-i18n-placeholder');
if (translations[currentLang] && translations[currentLang][key]) {
element.placeholder = translations[currentLang][key];
} else if (translations['ro'] && translations['ro'][key]) {
// Fallback to Romanian if translation is missing
element.placeholder = translations['ro'][key];
console.warn(`Missing placeholder translation for key "${key}" in language "${currentLang}", using Romanian`);
} else {
console.error(`Missing placeholder translation for key "${key}" in all languages`);
}
});
}
// Firebase functions for main page
function loadDataFromFirebase() {
showLoadingIndicator(true);
updateSyncStatus('syncing');
const playersRef = database.ref('players');
const metadataRef = database.ref('metadata');
// Listen for real-time updates
playersRef.on('value', (snapshot) => {
try {
const data = snapshot.val();
if (data) {
players = Object.values(data);
} else {
players = [];
}
updateDashboard();
renderTable();
showLoadingIndicator(false);
updateSyncStatus('synced');
} catch (error) {
console.error('Error loading data:', error);
showLoadingIndicator(false);
updateSyncStatus('error');
showNotification('Error loading data', 'error');
}
}, (error) => {
console.error('Database error:', error);
showLoadingIndicator(false);
updateSyncStatus('error');
showNotification('Database connection error', 'error');
});
// Get metadata
metadataRef.once('value').then((snapshot) => {
const metadata = snapshot.val();
if (metadata && metadata.lastUpdateTime) {
lastUpdateTime = new Date(metadata.lastUpdateTime);
}
updateLastUpdatedTime();
}).catch((error) => {
console.error('Error loading metadata:', error);
lastUpdateTime = new Date();
updateLastUpdatedTime();
});
}
function saveDataToFirebase() {
if (!currentUser) {
showNotification('Permission denied', 'error');
return;
}
// Disable save button to prevent multiple clicks
if (elements.saveBtn) {
elements.saveBtn.disabled = true;
}
showLoadingIndicator(true);
updateSyncStatus('syncing');
// Clear any existing timeout
if (syncTimeout) {
clearTimeout(syncTimeout);
}
const playersObj = {};
players.forEach((player, index) => {
playersObj[index] = player;
});
const metadata = {
lastUpdateTime: new Date().toISOString(),
version: '1.0'
};
// Save players data
database.ref('players').set(playersObj)
.then(() => {
// Save metadata
return database.ref('metadata').set(metadata);
})
.then(() => {
lastUpdateTime = new Date();
updateLastUpdatedTime();
showLoadingIndicator(false);
updateSyncStatus('synced');
showNotification(translations[currentLang].dataSaved, 'success');
// Re-enable save button after a delay
if (elements.saveBtn) {
setTimeout(() => {
elements.saveBtn.disabled = false;
}, 2000);
}
})
.catch((error) => {
console.error('Error saving data:', error);
showLoadingIndicator(false);
updateSyncStatus('error');
showNotification('Error saving data: ' + error.message, 'error');
// Re-enable save button after a delay
if (elements.saveBtn) {
setTimeout(() => {
elements.saveBtn.disabled = false;
}, 2000);
}
});
}
function updatePlayerScoreInFirebase(playerName, newScore) {
if (!currentUser) {
showNotification('Permission denied', 'error');
return;
}
const playerIndex = players.findIndex(p => p.player === playerName);
if (playerIndex === -1) return;
updateSyncStatus('syncing');
// Clear any existing timeout
if (syncTimeout) {
clearTimeout(syncTimeout);
}
// Update the player's score in Firebase
database.ref(`players/${playerIndex}/totalScores`).set(parseInt(newScore) || 0)
.then(() => {
// Update metadata
return database.ref('metadata/lastUpdateTime').set(new Date().toISOString());
})
.then(() => {
lastUpdateTime = new Date();
updateLastUpdatedTime();
updateSyncStatus('synced');
})
.catch((error) => {
console.error('Error updating player score:', error);
updateSyncStatus('error');
showNotification('Error updating score: ' + error.message, 'error');
});
}
// Firebase functions for daily tournaments page
function loadDailyDataFromFirebase() {
showLoadingIndicator(true);
updateSyncStatus('syncing');
const dailyPlayersRef = database.ref('dailyPlayers');
const dailyMetadataRef = database.ref('dailyMetadata');
// Listen for real-time updates
dailyPlayersRef.on('value', (snapshot) => {
try {
const data = snapshot.val();
if (data) {
dailyPlayers = Object.values(data);
} else {
dailyPlayers = [];
}
updateDailyDashboard();
renderDailyTable();
showLoadingIndicator(false);
updateSyncStatus('synced');
} catch (error) {
console.error('Error loading daily data:', error);
showLoadingIndicator(false);
updateSyncStatus('error');
showNotification('Error loading daily data', 'error');
}
}, (error) => {
console.error('Database error:', error);
showLoadingIndicator(false);
updateSyncStatus('error');
showNotification('Database connection error', 'error');
});
// Get metadata
dailyMetadataRef.once('value').then((snapshot) => {
const metadata = snapshot.val();
if (metadata && metadata.lastUpdateTime) {
dailyLastUpdateTime = new Date(metadata.lastUpdateTime);
}
updateDailyLastUpdatedTime();
}).catch((error) => {
console.error('Error loading daily metadata:', error);
dailyLastUpdateTime = new Date();
updateDailyLastUpdatedTime();
});
}
function saveDailyDataToFirebase() {
if (!currentUser) {
showNotification('Permission denied', 'error');
return;
}
// Disable save button to prevent multiple clicks
if (elements.dailySaveBtn) {
elements.dailySaveBtn.disabled = true;
}
showLoadingIndicator(true);
updateSyncStatus('syncing');
// Clear any existing timeout
if (syncTimeout) {
clearTimeout(syncTimeout);
}
const dailyPlayersObj = {};
dailyPlayers.forEach((player, index) => {
dailyPlayersObj[index] = player;
});
const metadata = {
lastUpdateTime: new Date().toISOString(),
version: '1.0'
};
// Save daily players data
database.ref('dailyPlayers').set(dailyPlayersObj)
.then(() => {
// Save metadata
return database.ref('dailyMetadata').set(metadata);
})
.then(() => {
dailyLastUpdateTime = new Date();
updateDailyLastUpdatedTime();
showLoadingIndicator(false);
updateSyncStatus('synced');
showNotification('Daily data saved successfully!', 'success');
// Re-enable save button after a delay
if (elements.dailySaveBtn) {
setTimeout(() => {
elements.dailySaveBtn.disabled = false;
}, 2000);
}
})
.catch((error) => {
console.error('Error saving daily data:', error);
showLoadingIndicator(false);
updateSyncStatus('error');
showNotification('Error saving daily data: ' + error.message, 'error');
// Re-enable save button after a delay
if (elements.dailySaveBtn) {
setTimeout(() => {
elements.dailySaveBtn.disabled = false;
}, 2000);
}
});
}
function updateDailyScoreInFirebase(playerName, date, score) {
if (!currentUser) {
showNotification('Permission denied', 'error');
return;
}
const playerIndex = dailyPlayers.findIndex(p => p.playerName === playerName);
if (playerIndex === -1) return;
updateSyncStatus('syncing');
// Clear any existing timeout
if (syncTimeout) {
clearTimeout(syncTimeout);
}
// Update the player's score in Firebase
database.ref(`dailyPlayers/${playerIndex}/scores/${date}`).set(score === '' ? null : parseInt(score))
.then(() => {
// Update metadata
return database.ref('dailyMetadata/lastUpdateTime').set(new Date().toISOString());
})
.then(() => {
dailyLastUpdateTime = new Date();
updateDailyLastUpdatedTime();
updateSyncStatus('synced');
})
.catch((error) => {
console.error('Error updating daily score:', error);
updateSyncStatus('error');
showNotification('Error updating daily score: ' + error.message, 'error');
});
}
// UI functions
function showLoadingIndicator(show) {
if (elements.loadingIndicator) {
if (show) {
elements.loadingIndicator.classList.add('active');
} else {
elements.loadingIndicator.classList.remove('active');
}
}
}
function updateSyncStatus(status) {
isSyncing = (status === 'syncing');
if (elements.syncStatus) {
elements.syncStatus.className = 'sync-status ' + status;
const icon = elements.syncStatus.querySelector('i');
const text = elements.syncStatus.querySelector('span');
switch (status) {
case 'syncing':
icon.className = 'fas fa-sync-alt';
text.textContent = 'Syncing...';
// Show sync status only when syncing
elements.syncStatus.classList.add('show');
break;
case 'synced':
icon.className = 'fas fa-check-circle';
text.textContent = 'Synced';
// Hide sync status when synced
elements.syncStatus.classList.remove('show');
break;
case 'error':
icon.className = 'fas fa-exclamation-circle';
text.textContent = 'Sync Error';
// Show sync status when there's an error
elements.syncStatus.classList.add('show');
// Auto-hide after 5 seconds
setTimeout(() => {
if (elements.syncStatus && elements.syncStatus.classList.contains('error')) {
elements.syncStatus.classList.remove('show');
}
}, 5000);
break;
}
}
}
function updateDashboard() {
try {
const totalPlayers = players.length;
const targetAchieved = players.filter(p => calculateLeftToAchieve(p) <= 0).length;
const closeToTarget = players.filter(p => calculateLeftToAchieve(p) > 0 && calculateLeftToAchieve(p) < 500).length;
const attentionNeeded = players.filter(p => calculateLeftToAchieve(p) >= 500).length;
const zeroPoints = players.filter(p => calculateWeekScore(p) === 0).length;
const weeklyAverage = totalPlayers > 0 ?
Math.round(players.reduce((sum, p) => sum + calculateWeekScore(p), 0) / totalPlayers) : 0;
if (elements.totalPlayers) elements.totalPlayers.textContent = totalPlayers;
if (elements.targetAchieved) elements.targetAchieved.textContent = targetAchieved;
if (elements.closeToTarget) elements.closeToTarget.textContent = closeToTarget;
if (elements.attentionNeeded) elements.attentionNeeded.textContent = attentionNeeded;
if (elements.zeroPoints) elements.zeroPoints.textContent = zeroPoints;
if (elements.weeklyAverage) elements.weeklyAverage.textContent = weeklyAverage;
} catch (error) {
console.error('Error updating dashboard:', error);
}
}
function updateDailyDashboard() {
try {
const totalPlayers = dailyPlayers.length;
const top10Players = dailyPlayers.filter(p => calculateDailyAverage(p) > 0).sort((a, b) => calculateDailyAverage(b) - calculateDailyAverage(a)).slice(0, 10).length;
const top32Players = dailyPlayers.filter(p => calculateDailyAverage(p) > 0).sort((a, b) => calculateDailyAverage(b) - calculateDailyAverage(a)).slice(0, 32).length;
const missedTournaments = dailyPlayers.filter(p => hasMissedTournament(p)).length;
const min2Missed = dailyPlayers.filter(p => hasMin2MissedTournaments(p)).length;
if (elements.dailyTotalPlayers) elements.dailyTotalPlayers.textContent = totalPlayers;
if (elements.top10Players) elements.top10Players.textContent = top10Players;
if (elements.top32Players) elements.top32Players.textContent = top32Players;
if (elements.missedTournaments) elements.missedTournaments.textContent = missedTournaments;
if (elements.min2Missed) elements.min2Missed.textContent = min2Missed;
} catch (error) {
console.error('Error updating daily dashboard:', error);
}
}
// Sort players function for main page
function sortPlayers(players, sortMethod) {
const sortedPlayers = [...players];
switch(sortMethod) {
case 'rank':
// Sort by rank (default)
sortedPlayers.sort((a, b) => {
const rankA = calculateRank(a);
const rankB = calculateRank(b);
return rankA - rankB;
});
break;
case 'name':
// Sort by name (alphabetical)
sortedPlayers.sort((a, b) => {
return a.player.localeCompare(b.player);
});
break;
case 'score':
// Sort by total score (highest to lowest)
sortedPlayers.sort((a, b) => {
return b.totalScores - a.totalScores;
});
break;
default:
// Default sort by rank
sortedPlayers.sort((a, b) => {
const rankA = calculateRank(a);
const rankB = calculateRank(b);
return rankA - rankB;
});
}
return sortedPlayers;
}
// Sort players function for daily page
function sortDailyPlayers(players, sortMethod) {
const sortedPlayers = [...players];
switch(sortMethod) {
case 'rank':
// Sort by rank (default)
sortedPlayers.sort((a, b) => {
const rankA = calculateDailyRank(a);
const rankB = calculateDailyRank(b);
return rankA - rankB;
});
break;
case 'name':
// Sort by name (alphabetical)
sortedPlayers.sort((a, b) => {
return a.playerName.localeCompare(b.playerName);
});
break;
default:
// Default sort by rank
sortedPlayers.sort((a, b) => {
const rankA = calculateDailyRank(a);
const rankB = calculateDailyRank(b);
return rankA - rankB;
});
}
return sortedPlayers;
}
function renderTable() {
try {
// Filter players
let filteredPlayers = players.filter(player => {
if (searchQuery && !player.player.toLowerCase().includes(searchQuery)) {
return false;
}
switch (activeFilter) {
case 'target':
return calculateLeftToAchieve(player) <= 0;
case 'close':
return calculateLeftToAchieve(player) > 0 && calculateLeftToAchieve(player) < 500;
case 'attention':
return calculateLeftToAchieve(player) >= 500;
case 'zero':
return calculateWeekScore(player) === 0;
default:
return true;
}
});
// Sort players according to selected method
filteredPlayers = sortPlayers(filteredPlayers, currentSortMethod);
// Clear table
if (elements.rankingBody) {
elements.rankingBody.innerHTML = '';
}
// Render rows
filteredPlayers.forEach(player => {
const row = document.createElement('tr');
const weekScore = calculateWeekScore(player);
const leftToAchieve = calculateLeftToAchieve(player);
const statusClass = getStatusClass(player);
const statusText = getStatusText(player);
const isZeroScore = weekScore === 0;
const canEdit = currentUser;
row.innerHTML = `
<td class="rank">${calculateRank(player)}</td>
<td class="player ${statusClass}">${player.player}</td>
<td class="total-scores">
${canEdit ?
`<input type="number" class="editable" value="${player.totalScores}"
onchange="updatePlayerScore('${player.player}', this.value)">` :
player.totalScores}
</td>
<td class="week-score ${isZeroScore ? 'zero-score' : ''}">${weekScore}</td>
<td class="left-to-achieve ${statusClass}">${statusText}</td>
`;
if (elements.rankingBody) {
elements.rankingBody.appendChild(row);
}
});
} catch (error) {
console.error('Error rendering table:', error);
}
}
function renderDailyTable() {
try {
// Get all date columns
const dateColumns = [];
document.querySelectorAll('#dailyTournamentsTable th[data-date]').forEach(th => {
dateColumns.push(th.getAttribute('data-date'));
});
        
// Filter players
let filteredPlayers = dailyPlayers.filter(player => {
// Validate player object
if (!player || !player.playerName) {
return false;
}
            
// Apply search filter
if (dailySearchQuery && !player.playerName.toLowerCase().includes(dailySearchQuery)) {
return false;
}
            
// Apply dashboard filter
switch (dailyActiveFilter) {
case 'top10':
return calculateDailyRank(player) <= 10;
case 'top32':
return calculateDailyRank(player) <= 32;
case 'missed':
return hasMissedTournament(player);
case 'min2missed':
return hasMin2MissedTournaments(player);
default:
return true;
}
});
        
// Sort players according to selected method
filteredPlayers = sortDailyPlayers(filteredPlayers, dailyCurrentSortMethod);
        
// Clear table
if (elements.dailyTournamentsBody) {
elements.dailyTournamentsBody.innerHTML = '';
}
        
// Render rows
filteredPlayers.forEach(player => {
const row = document.createElement('tr');
const average = calculateDailyAverage(player);
const nrTournaments = calculateNrTournaments(player);
const canEdit = currentUser;
            
// Check if player has any zero scores
const hasZero = player.scores && Object.values(player.scores).some(score => score === 0);
            
row.innerHTML = `
<td class="rank">${calculateDailyRank(player)}</td>
<td class="player player-name ${hasZero ? 'has-zero' : ''}">${player.playerName}</td>
<td class="average">${Math.round(average)}</td>
<td class="nr-tournaments">${nrTournaments}</td>
`;
            
// Add date columns in reverse order (most recent first)
const dateColumnsReversed = [...dateColumns].reverse();
dateColumnsReversed.forEach(date => {
const cell = document.createElement('td');
cell.setAttribute('data-date', date);
                
if (player.scores && player.scores[date] !== undefined && player.scores[date] !== null) {
const score = player.scores[date];
if (score === 0) {
cell.classList.add('zero-value');
}
cell.innerHTML = `<input type="number" class="editable" value="${score}" 
onchange="updateDailyScore('${player.playerName}', '${date}', this.value)">`;
} else {
cell.innerHTML = `<input type="number" class="editable" value="" 
onchange="updateDailyScore('${player.playerName}', '${date}', this.value)">`;
}
                
row.appendChild(cell);
});
            
if (elements.dailyTournamentsBody) {
elements.dailyTournamentsBody.appendChild(row);
}
});
} catch (error) {
console.error('Error rendering daily table:', error);
}
}
function setActiveFilter(filter) {
activeFilter = filter;
// Update active state
if (elements.statCards) {
elements.statCards.forEach(card => {
card.classList.remove('active');
if (card.getAttribute('data-filter') === filter) {
card.classList.add('active');
}
});
}
renderTable();
}
function setDailyActiveFilter(filter) {
dailyActiveFilter = filter;
// Update active state
if (elements.dailyStatCards) {
elements.dailyStatCards.forEach(card => {
card.classList.remove('active');
if (card.getAttribute('data-daily-filter') === filter) {
card.classList.add('active');
}
});
}
renderDailyTable();
}
function updateLastUpdatedTime() {
if (!lastUpdateTime) {
if (elements.updateTime) {
elements.updateTime.textContent = translations[currentLang].never;
}
return;
}
const now = new Date();
const diff = now - lastUpdateTime;
const minutes = Math.floor(diff / 60000);
const hours = Math.floor(diff / 3600000);
const days = Math.floor(diff / 86400000);
let timeText;
if (days > 0) {
timeText = `${days} ${translations[currentLang].days}`;
} else if (hours > 0) {
timeText = `${hours} ${translations[currentLang].hours}`;
} else {
timeText = `${minutes} ${translations[currentLang].minutes}`;
}
if (elements.updateTime) {
elements.updateTime.textContent = timeText;
}
}
function updateDailyLastUpdatedTime() {
if (!dailyLastUpdateTime) {
if (elements.dailyUpdateTime) {
elements.dailyUpdateTime.textContent = translations[currentLang].never;
}
return;
}
const now = new Date();
const diff = now - dailyLastUpdateTime;
const minutes = Math.floor(diff / 60000);
const hours = Math.floor(diff / 3600000);
const days = Math.floor(diff / 86400000);
let timeText;
if (days > 0) {
timeText = `${days} ${translations[currentLang].days}`;
} else if (hours > 0) {
timeText = `${hours} ${translations[currentLang].hours}`;
} else {
timeText = `${minutes} ${translations[currentLang].minutes}`;
}
if (elements.dailyUpdateTime) {
elements.dailyUpdateTime.textContent = timeText;
}
}
function showNotification(message, type) {
if (elements.notificationMessage) {
elements.notificationMessage.textContent = message;
}
if (elements.notification) {
// Remove existing notification
elements.notification.classList.remove('show');
// Force reflow to restart animation
void elements.notification.offsetWidth;
elements.notification.className = `notification ${type}`;
elements.notification.classList.add('show');
}
// Auto-hide after 3 seconds
setTimeout(() => {
if (elements.notification) {
elements.notification.classList.remove('show');
}
}, 3000);
}
// Calculation functions for main page
function calculateWeekScore(player) {
if (!player || typeof player.totalScores === 'undefined' || typeof player.startingPoints === 'undefined') {
return 0;
}
return player.totalScores - player.startingPoints;
}
function calculateLeftToAchieve(player) {
if (!player || typeof player.targetPoints === 'undefined' || typeof player.totalScores === 'undefined') {
return 0;
}
return player.targetPoints - player.totalScores;
}
function calculateRank(player) {
if (!player) return 0;
const sortedPlayers = [...players].sort((a, b) => {
const weekScoreA = calculateWeekScore(a);
const weekScoreB = calculateWeekScore(b);
if (weekScoreB !== weekScoreA) {
return weekScoreB - weekScoreA;
}
return a.player.localeCompare(b.player);
});
return sortedPlayers.findIndex(p => p.player === player.player) + 1;
}
function getStatusClass(player) {
const leftToAchieve = calculateLeftToAchieve(player);
if (leftToAchieve <= 0) return 'status-done';
if (leftToAchieve < 200) return 'status-gray';
if (leftToAchieve < 500) return 'status-yellow';
return 'status-red';
}
function getStatusText(player) {
const leftToAchieve = calculateLeftToAchieve(player);
if (leftToAchieve <= 0) return translations[currentLang].done;
return leftToAchieve;
}
// Calculation functions for daily page
function calculateDailyAverage(player) {
    if (!player || !player.scores) return 0;
    let total = 0;
    let count = 0;
    Object.entries(player.scores).forEach(([date, score]) => {
        // MODIFICATION: Skip zeros in average calculation
        if (score !== null && score !== undefined && score > 0) {
            total += score;
            count++;
        }
    });
    return count > 0 ? total / count : 0;
}
function calculateNrTournaments(player) {
if (!player || !player.scores) return 0;
let count = 0;
Object.values(player.scores).forEach(score => {
if (score !== null && score !== undefined) {
count++;
}
});
return count;
}
function calculateDailyRank(player) {
if (!player || !player.playerName) return 0;
const sortedPlayers = [...dailyPlayers].filter(p => p && p.playerName).sort((a, b) => {
const avgA = calculateDailyAverage(a);
const avgB = calculateDailyAverage(b);
if (avgB !== avgA) {
return avgB - avgA;
}
// Fix for localeCompare error - check if playerName exists
if (a.playerName && b.playerName) {
return a.playerName.localeCompare(b.playerName);
}
return 0;
});
return sortedPlayers.findIndex(p => p.playerName === player.playerName) + 1;
}
function hasMissedTournament(player) {
if (!player || !player.scores) return false;
return Object.values(player.scores).some(score => score === 0);
}
function hasMin2MissedTournaments(player) {
if (!player || !player.scores) return false;
const missedCount = Object.values(player.scores).filter(score => score === 0).length;
return missedCount >= 2;
}
// File handling functions for main page
function handleFileImport(event) {
if (!currentUser || userRole !== 'admin') {
showNotification('Permission denied', 'error');
return;
}
const file = event.target.files[0];
if (!file) return;
// Validate file type
if (!file.name.match(/\.(xlsx|xls)$/)) {
showNotification('Please select a valid Excel file', 'error');
return;
}
showLoadingIndicator(true);
updateSyncStatus('syncing');
const reader = new FileReader();
reader.onload = function(e) {
try {
const data = new Uint8Array(e.target.result);
const workbook = XLSX.read(data, { type: 'array' });
if (!workbook.SheetNames || workbook.SheetNames.length === 0) {
throw new Error('No sheets found in the Excel file');
}
const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
if (!jsonData || jsonData.length < 2) {
throw new Error('No data found in the Excel file');
}
// Process imported data
const newPlayers = [];
for (let i = 1; i < jsonData.length; i++) {
const row = jsonData[i];
if (row && row[1]) { // Check if player name exists
newPlayers.push({
player: String(row[1]),
startingPoints: parseInt(row[2]) || 0,
targetPoints: parseInt(row[3]) || 0,
totalScores: parseInt(row[4]) || 0
});
}
}
if (newPlayers.length === 0) {
throw new Error('No valid player data found');
}
// Save to Firebase
const playersObj = {};
newPlayers.forEach((player, index) => {
playersObj[index] = player;
});
const metadata = {
lastUpdateTime: new Date().toISOString(),
version: '1.0'
};
database.ref('players').set(playersObj)
.then(() => {
return database.ref('metadata').set(metadata);
})
.then(() => {
lastUpdateTime = new Date();
updateLastUpdatedTime();
showLoadingIndicator(false);
updateSyncStatus('synced');
showNotification(translations[currentLang].importSuccess, 'success');
})
.catch((error) => {
console.error('Error importing data:', error);
showLoadingIndicator(false);
updateSyncStatus('error');
showNotification('Error importing data: ' + error.message, 'error');
});
} catch (error) {
console.error('Error processing file:', error);
showLoadingIndicator(false);
updateSyncStatus('error');
showNotification('Error processing file: ' + error.message, 'error');
}
};
reader.onerror = function() {
console.error('Error reading file');
showLoadingIndicator(false);
updateSyncStatus('error');
showNotification('Error reading file', 'error');
};
reader.readAsArrayBuffer(file);
event.target.value = '';
}
function exportData() {
try {
// Create Excel file
const exportData = players.map(player => ({
Rank: calculateRank(player),
Player: player.player,
'Starting Points': player.startingPoints,
'Target Points': player.targetPoints,
'Total Scores': player.totalScores,
'Week Score': calculateWeekScore(player),
'Left to Achieve': calculateLeftToAchieve(player)
}));
if (exportData.length === 0) {
showNotification('No data to export', 'error');
return;
}
const worksheet = XLSX.utils.json_to_sheet(exportData);
const workbook = XLSX.utils.book_new();
XLSX.utils.book_append_sheet(workbook, worksheet, 'Scoring Data');
XLSX.writeFile(workbook, 'scoring_data.xlsx');
showNotification(translations[currentLang].exportSuccess, 'success');
} catch (error) {
console.error('Error exporting data:', error);
showNotification('Error exporting data: ' + error.message, 'error');
}
}
// File handling functions for daily page
function handleDailyFileImport(event) {
    if (!currentUser || userRole !== 'admin') {
        showNotification('Permission denied', 'error');
        return;
    }
    
    const file = event.target.files[0];
    if (!file) return;
    
    // Validate file type
    if (!file.name.match(/\.(xlsx|xls)$/)) {
        showNotification('Please select a valid Excel file', 'error');
        return;
    }
    
    showLoadingIndicator(true);
    updateSyncStatus('syncing');
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            
            if (!workbook.SheetNames || workbook.SheetNames.length === 0) {
                throw new Error('No sheets found in the Excel file');
            }
            
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
            
            if (!jsonData || jsonData.length < 2) {
                throw new Error('No data found in the Excel file');
            }
            
            // Get headers from the first row
            const headers = jsonData[0];
            
            // Find the Player Name column index
            const playerNameIndex = headers.findIndex(header => 
                header && header.toString().toLowerCase().includes('player')
            );
            
            if (playerNameIndex === -1) {
                throw new Error('Player Name column not found');
            }
            
            // Get all existing date columns from current data
            const existingDateColumns = new Set();
            dailyPlayers.forEach(player => {
                if (player.scores) {
                    Object.keys(player.scores).forEach(date => {
                        existingDateColumns.add(date);
                    });
                }
            });
            
            // Process imported data - only import player names
            const importedPlayerNames = [];
            for (let i = 1; i < jsonData.length; i++) {
                const row = jsonData[i];
                if (row && row[playerNameIndex]) { // Check if player name exists
                    const playerName = String(row[playerNameIndex]).trim();
                    if (playerName && !importedPlayerNames.includes(playerName)) {
                        importedPlayerNames.push(playerName);
                    }
                }
            }
            
            if (importedPlayerNames.length === 0) {
                throw new Error('No valid player names found');
            }
            
            // Merge with existing players
            const updatedPlayers = [...dailyPlayers];
            
            // Add new players that don't already exist
            importedPlayerNames.forEach(playerName => {
                if (!updatedPlayers.some(p => p.playerName === playerName)) {
                    // Create new player with empty scores for all existing date columns
                    const scores = {};
                    existingDateColumns.forEach(date => {
                        scores[date] = null;
                    });
                    
                    updatedPlayers.push({
                        playerName: playerName,
                        scores: scores
                    });
                }
            });
            
            // Update dailyPlayers array
            dailyPlayers = updatedPlayers;
            
            // Save to Firebase
            const dailyPlayersObj = {};
            dailyPlayers.forEach((player, index) => {
                dailyPlayersObj[index] = player;
            });
            
            const metadata = {
                lastUpdateTime: new Date().toISOString(),
                version: '1.0'
            };
            
            database.ref('dailyPlayers').set(dailyPlayersObj)
                .then(() => {
                    return database.ref('dailyMetadata').set(metadata);
                })
                .then(() => {
                    dailyLastUpdateTime = new Date();
                    updateDailyLastUpdatedTime();
                    showLoadingIndicator(false);
                    updateSyncStatus('synced');
                    showNotification('Players imported successfully!', 'success');
                    // Regenerate columns and refresh table
                    checkDailyColumns();
                    renderDailyTable();
                })
                .catch((error) => {
                    console.error('Error importing daily data:', error);
                    showLoadingIndicator(false);
                    updateSyncStatus('error');
                    showNotification('Error importing daily data: ' + error.message, 'error');
                });
        } catch (error) {
            console.error('Error processing file:', error);
            showLoadingIndicator(false);
            updateSyncStatus('error');
            showNotification('Error processing file: ' + error.message, 'error');
        }
    };
    
    reader.onerror = function() {
        console.error('Error reading file');
        showLoadingIndicator(false);
        updateSyncStatus('error');
        showNotification('Error reading file', 'error');
    };
    
    reader.readAsArrayBuffer(file);
    event.target.value = '';
}
function exportDailyData() {
    try {
        // Get all date columns in reverse order (most recent first)
        const dateColumns = [];
        document.querySelectorAll('#dailyTournamentsTable th[data-date]').forEach(th => {
            dateColumns.unshift(th.getAttribute('data-date')); // Add to beginning to reverse order
        });
        
        // Create Excel file
        const exportData = dailyPlayers.filter(player => player && player.playerName).map(player => {
            const row = {
                Rank: calculateDailyRank(player),
                'Player Name': player.playerName,
                Average: Math.round(calculateDailyAverage(player)),
                'Nr. Tournament': calculateNrTournaments(player)
            };
            
            // Add scores for each date
            dateColumns.forEach(date => {
                row[date] = (player.scores && player.scores[date] !== undefined && player.scores[date] !== null) ? player.scores[date] : '';
            });
            
            return row;
        });
        
        if (exportData.length === 0) {
            showNotification('No data to export', 'error');
            return;
        }
        
        const worksheet = XLSX.utils.json_to_sheet(exportData);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Daily Tournaments Data');
        
        // Generate filename with current date
        const now = new Date();
        const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
        const filename = `daily_tournaments_data_${dateStr}.xlsx`;
        
        XLSX.writeFile(workbook, filename);
        showNotification('Daily data exported successfully!', 'success');
    } catch (error) {
        console.error('Error exporting daily data:', error);
        showNotification('Error exporting daily data: ' + error.message, 'error');
    }
}
// Global functions for inline event handlers
window.updatePlayerScore = function(playerName, newScore) {
if (!currentUser) {
showNotification('Permission denied', 'error');
return;
}
const player = players.find(p => p.player === playerName);
if (player) {
player.totalScores = parseInt(newScore) || 0;
updatePlayerScoreInFirebase(playerName, newScore);
}
};
window.updateDailyScore = function(playerName, date, score) {
if (!currentUser) {
showNotification('Permission denied', 'error');
return;
}
const player = dailyPlayers.find(p => p.playerName === playerName);
if (player) {
if (!player.scores) {
player.scores = {};
}
player.scores[date] = score === '' ? null : parseInt(score) || null;
updateDailyScoreInFirebase(playerName, date, score);
    
    // Find the row for this player
    const rows = document.querySelectorAll('#dailyTournamentsBody tr');
    for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const nameCell = row.querySelector('.player-name');
        if (nameCell && nameCell.textContent === playerName) {
            // Update the date cell
            const targetCell = row.querySelector(`td[data-date="${date}"]`);
            if (targetCell) {
                if (score === '0') {
                    targetCell.classList.add('zero-value');
                } else {
                    targetCell.classList.remove('zero-value');
                }
            }
            
            // Check if the player has any zero in the scores
            const hasZero = player.scores && Object.values(player.scores).some(s => s === 0);
            if (hasZero) {
                nameCell.classList.add('has-zero');
            } else {
                nameCell.classList.remove('has-zero');
            }
            
            // Update the average cell
            const avgCell = row.querySelector('.average');
            if (avgCell) {
                avgCell.textContent = Math.round(calculateDailyAverage(player));
            }
            
            break;
        }
    }
    
    // Update dashboard
    updateDailyDashboard();
}
};
// Initialize app when DOM is loaded
document.addEventListener('DOMContentLoaded', initApp);
</script>
</body>
</html>
